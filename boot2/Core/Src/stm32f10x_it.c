//******************************************************************************
//
//
//
//******************************************************************************

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< defines >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< includes >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#include "stm32f10x_it.h"

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< global variables >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
uint32_t timer=0,endtimer=0;;
volatile bool fPassed500ms=false,fPassed10s=false;

//<<<<<<<<<<<<<<<<<<<<<<<<<<<< function prototypes >>>>>>>>>>>>>>>>>>>>>>>>>>>>>


/******************************************************************************/
/*            Cortex-M3 Processor Exceptions Handlers                         */
/******************************************************************************/

//==============================================================================
// 	@Описание: 	Non maskable interrupt. The RCC Clock Security System (CSS) 
//				is linked to the NMI vector.
//	@Аргуметры:	нет	 
//	@Результат: нет
//==============================================================================
void NMI_Handler(void)
{
	
}

//==============================================================================
// 	@Описание: 	All class of fault.
//	@Аргуметры:	нет	 
//	@Результат: нет
//==============================================================================
void HardFault_Handler(void)
{
	// 100мс пауза, не убирать! иначе вероятности подключения JTAG-ом стремится 
	// к нулю т.к. МК будет в постоянном сбросе
  	Wait_ms(100);
  	// перезагрузка МК
  	NVIC_SystemReset();
}

//==============================================================================
// 	@Описание: 	Memory management.
//	@Аргуметры:	нет	 
//	@Результат: нет
//==============================================================================
void MemManage_Handler(void)
{
	// 100мс пауза, не убирать! иначе вероятности подключения JTAG-ом стремится 
	// к нулю т.к. МК будет в постоянном сбросе
  	Wait_ms(100);
  	// перезагрузка МК
  	NVIC_SystemReset();
}

//==============================================================================
// 	@Описание: 	Pre-fetch fault, memory access fault.
//	@Аргуметры:	нет	 
//	@Результат: нет
//==============================================================================
void BusFault_Handler(void)
{
	// 100мс пауза, не убирать! иначе вероятности подключения JTAG-ом стремится 
	// к нулю т.к. МК будет в постоянном сбросе
  	Wait_ms(100);
  	// перезагрузка МК
  	NVIC_SystemReset();
}

//==============================================================================
// 	@Описание: 	Undefined instruction or illegal state.
//	@Аргуметры:	нет	 
//	@Результат: нет
//==============================================================================
void UsageFault_Handler(void)
{
	// 100мс пауза, не убирать! иначе вероятности подключения JTAG-ом стремится 
	// к нулю т.к. МК будет в постоянном сбросе
  	Wait_ms(100);
  	// перезагрузка МК
  	NVIC_SystemReset();
}

//==============================================================================
// 	@Описание: 	Debug Monitor.
//	@Аргуметры:	нет	 
//	@Результат: нет
//==============================================================================
void DebugMon_Handler(void)
{
	
}

//==============================================================================
// 	@Описание: 	System service call via SWI instruction.
//	@Аргуметры:	нет	 
//	@Результат: нет
//==============================================================================
void SVC_Handler(void)
{
	
}

//==============================================================================
// 	@Описание: 	Pendable request for system service.
//	@Аргуметры:	нет	 
//	@Результат: нет
//==============================================================================
void PendSV_Handler(void)
{
	
}

//==============================================================================
// 	@Описание: 	System tick timer.
//	@Аргуметры:	нет	 
//	@Результат: нет
//==============================================================================
void SysTick_Handler(void)
{
	timer+=BOOT_SYSTICKPERIOD_MS;
	if((timer%500)==0)
	{
		fPassed500ms=true;
		if(timer >= 10000)
		{
			fPassed10s=true;
			timer=0;
		}
	}
}

/******************************************************************************/
/*                 STM32F10x Peripherals Interrupt Handlers                   */
/*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
/*  available peripheral interrupt handler's name please refer to the startup */
/*  file (startup_stm32f10x_xx.s).                                            */
/******************************************************************************/
/**
  * @brief  This function handles ETH interrupt request.
  * @param  None
  * @retval None
  */
void ETH_IRQHandler(void)
{

}

/**
  * @brief  This function handles ETH  Weke-up interrupt request.
  * @param  None
  * @retval None
  */
void ETH_WKUP_IRQHandler(void)
{

}


//******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
